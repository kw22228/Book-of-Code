/*
  순차 탐색 알고리즘으로 시간 복잡도를 계산해보자.
  이 알고리즘에서 사용된 연산자는 [<, ++, ===] 이렇게 3개이다.
  이중 === 연산을 적게 수행해야 나머지 <, ++ 연산도 적게 하기 때문에 좋은 알고리즘이다.
  따라서 === 연산의 횟수를 대상으로 시간 복잡도를 구성하면 되겟다.

  ### 시간 복잡도
  - 최악의 경우 (worst case)
    - 데이터의 수가 n일때, 최악의 경우 해당하는 연산횟수(비교 연산횟수)는 n이다.
    - 따라서, 데이터 수 n에 대한 연산횟수의 함수 T(n)은 [ T(n) = n ] 과 같다.

  - 평균적이 경우 (average case)
    - 탑색 대상이 배열에 존재하지 않을 확률을 50%라고 가정
    - 배열의 첫 요소부터 마지막 요소까지, 탐색 대상이 존재할 확률은 동일하다.
    - 따라서, 배열의 탐색 대상이 존재하는 경우와 존재하지 않는 경우를 나눠서 연산횟수를 계산.
      - 탐색 대상이 존재하지 않는 경우: 데이터가 n개일때 연산횟수도 n
      - 탐색 대상이 존재 할 경우 (50% 확률): n/2
      - 탐색 대상이 배열에 존재하는경우가 50%확률이니
        n _ (1/2) + n/2 _ (1/2) = 3/4n 이다.
        T(n) = 3/4n
*/

function lSearch(arr, len, target) {
  for (let i = 0; i < len; i++) {
    if (arr[i] === target) return i;
  }
  return -1;
}

const arr = [3, 5, 2, 4, 9];
const idx = lSearch(arr, arr.length, 4);
console.log(idx);
