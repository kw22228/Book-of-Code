### 데코레이터 패턴

#### 디자인원칙 (OCP - Open Closed Principle)

- 클래스에서 확장은 열려 있어야 하지만 변경에는 닫혀있어야한다.
- 상속보다는 컴포지션과 델리게이션을 사용함으로써 기존의 코드는 변경할 필요없이 무수하게 확장할 수 있다.

#### 상속으로 만든 커피주문기의 제약사항

1. 커피 제품이 늘어나면 계속 적으로 클래스를 만들어줘야해서 어마어마하게 많은 클래스가 생성될 수 있음.
2. 일부 서브클래스에서는 적합하지 않은 기능을 모든 서브클래스에서 똑같이 상속받아야한다.
3. 첨가물이나 음료의 가격이 변동사항이 있을때 너무많은 코드를 수정해야한다.
4. 클래스를 확장하기에 용이하지 않다. (기존에 코드를 변경해야하는 상황이 생김.)

#### 데코레이터 패턴의 정의

- 데코레이터 패턴으로 객체에 추가 요소를 동적으로 더할 수 있다.
- 데코레이터를 사용하면 서브클래스를 만들 때보다 훨씬 유연하게 기능을 확장할 수 있다.

#### 데코레이터 특징

- 데코레이터의 슈퍼클래스는 자신이 장식하고 있는 객체의 슈퍼클래스와 같다.
- 한 객체를 여러 개의 데코레이터로 감쌀 수 있다.
- 데코레이터는 자신이 감싸고 있는 객체와 같은 슈퍼클래스를 가지고 있기에 원래 객체(싸여 있는 객체)가 들어갈 자리에 데코레이터 객체를 넣어도 상관없다.
- 데코레이터는 자신이 장식하고 있는 객체에게 어떤 행동을 위임하는 일 말고도 추가작업을 수행할 수 있다.
- 객체는 언제든지 감쌀 수 있으므로 실행 중에 필요한 데코레이터를 마음대로 적용할 수 있다.

#### 데코레이터 패턴을 적용시킨 커피주문기

- 실행
  1. Decaf(Beverage) 객체 시작.
  2. 고객이 Mocha를 주문하여 Mocha객체를 만들고 Decaf를 감싼다. (데코레이터 한다)
  3. 고객이 Whip도 추가하였으니 Whip객체를 만들고 데코레이터 한다.
  4. 먼저 가장 바깥쪽에 있는 데코레이터인 Whip객체의 cost()를 호출한다.
  5. Whip은 그안쪽의 Mocha의 cost()를 호출.
  6. Mocha는 그 안의 Decaf(Beverage)의 cost()를 호출한다.
  7. Decaf는 5500원을 리턴한다.
  8. Mocha는 Decaf의 리턴값 + 2000원(Mocha값)을 리턴한다. (7500원)
  9. Whip은 Mocha의 리턴값 + 500(Whip값)을 리턴한다. (8000원)
  10. 최종적으로 8000원 리턴.
