### 전략 패턴 (오리 시뮬레이션)

- Duck 이라는 슈퍼클래스가 있다.

  1. 차별화 하기

  - 오리가 날 수 있다는 기능을 넣고자 슈퍼클래스에 fly() 메소드를 추가하여 자식들이 공유받을 수 있게한다.

  2. 문제 발생

  - 모든 오리가 나는게 아니라 몇몇의 오리만 날게 해야한다.
  - 날지 못하는 오리만 fly() 메소드를 오버라이드해 아무것도 못하게 한다.
    이렇게 하면 서브클래스에 여러가지 문제점이 생김

  3. 인터페이스 설계하기

  - 꽥꽥 거리는 오리의 인터페이스 구현 Quackable.quack()
  - 날 수 있는 오리의 인터페이스 구현 Flyable.fly()
  - 문제점: 하지만 이렇게 몇몇의 오리에 오버라이딩 하기 싫어 인터페이스를 구현하게 된다면 유지보수가 더힘들 수 있다.
    모든 서브클래스에 오리가 할 수 있는 기능에 맞춰 인터페이스를 매핑해주면 작업이 너무 많아짐.

- 기존의 코드 해결책

  1. 바뀌는 부분과 그렇지 않은 부분 분리하기

     - 변화하는 부분과 그대로 있는 부분을 2개의 클래스 집합으로 만들어야 한다.
     - fly()와 quack()은 Duck클래스에 오리 종류에 따라 달라지는 부분이다.
       따라서 Duck클래스에서 끄집어 내어 각 행동을 나타낼 클래스 집합을 새로 만든다.

  2. 오리의 행동을 디자인하는 방법

     - Duck 클래스에 행동과 관련된 세터 메소드를 포함하여 프로그램 실행 중에도 행동을 바꿀 수 있게 한다.
     - 디자인 원칙: 구현보다는 인터페이스(FlyBehavior, QuackBehavior)에 맞춰서 프로그래밍 한다.
     - 구조
       <<Interface>>
       FlyBehavior
       fly()

       FlyWithWings
       fly() 나는 방법 구현

       FlyNoWay
       fly() 날 수 없다. 암것도 못함

  3. 오리 행동 통합하기
     - Duck클래스에 행동에 대한 필드를 만들고 그 필드에 유동적으로 행동에 대한 인터페이스 클래스를 위임(deligate) 해주자.
     - 이 필드를 캡슐화 하여 상황에 따라서 행동도 변할 수 있게 해주자. (setter를 통해 새로운 위임)
